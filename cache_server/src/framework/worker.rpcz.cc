// Generated by the protocol buffer compiler.  DO NOT EDIT!

#include "worker.rpcz.h"
#include "worker.pb.h"
#include <google/protobuf/descriptor.h>
#include <google/protobuf/stubs/once.h>
#include <rpcz/rpcz.hpp>
namespace {
const ::google::protobuf::ServiceDescriptor* WorkerService_descriptor_ = NULL;
}  // anonymouse namespace

namespace node {

void rpcz_protobuf_AssignDesc_worker_2eproto() {
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "worker.proto");
  GOOGLE_CHECK(file != NULL);
  WorkerService_descriptor_ = file->service(0);
}

namespace {

::google::protobuf::internal::once_flag protobuf_AssignDescriptors_once_;
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::internal::call_once(protobuf_AssignDescriptors_once_,
                 &rpcz_protobuf_AssignDesc_worker_2eproto);
}

}  // namespace

// ===================================================================

WorkerService::~WorkerService() {}

const ::google::protobuf::ServiceDescriptor* WorkerService::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WorkerService_descriptor_;
}

const ::google::protobuf::ServiceDescriptor* WorkerService::GetDescriptor() {
  protobuf_AssignDescriptorsOnce();
  return WorkerService_descriptor_;
}

void WorkerService::HandleProtocol(const ::node::DataPacket&,
                         ::rpcz::reply< ::node::DataPacket> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method HandleProtocol() not implemented.");
}

void WorkerService::HandleNotification(const ::node::DataPacket&,
                         ::rpcz::reply< ::node::DataPacket> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method HandleNotification() not implemented.");
}

void WorkerService::ListProtocolInterests(const ::node::VoidPacket&,
                         ::rpcz::reply< ::node::InterestPacket> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method ListProtocolInterests() not implemented.");
}

void WorkerService::ListNotificationInterests(const ::node::VoidPacket&,
                         ::rpcz::reply< ::node::InterestPacket> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method ListNotificationInterests() not implemented.");
}

void WorkerService::KickLogged(const ::node::DataPacket&,
                         ::rpcz::reply< ::node::DataPacket> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method KickLogged() not implemented.");
}

void WorkerService::SendToClient(const ::node::DataPacket&,
                         ::rpcz::reply< ::node::DataPacket> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method SendToClient() not implemented.");
}

void WorkerService::BroadcastToClient(const ::node::BroadcastRequest&,
                         ::rpcz::reply< ::node::VoidPacket> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method BroadcastToClient() not implemented.");
}

void WorkerService::SendToPlayer(const ::node::ForwardRequest&,
                         ::rpcz::reply< ::node::DataPacket> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method SendToPlayer() not implemented.");
}

void WorkerService::PostToPlayer(const ::node::ForwardRequest&,
                         ::rpcz::reply< ::node::VoidPacket> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method PostToPlayer() not implemented.");
}

void WorkerService::CloseClient(const ::node::DataPacket&,
                         ::rpcz::reply< ::node::DataPacket> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method CloseClient() not implemented.");
}

void WorkerService::CloseAllClients(const ::node::BroadcastRequest&,
                         ::rpcz::reply< ::node::VoidPacket> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method CloseAllClients() not implemented.");
}

void WorkerService::SendToWorker(const ::node::DataPacket&,
                         ::rpcz::reply< ::node::DataPacket> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method SendToWorker() not implemented.");
}

void WorkerService::call_method(const ::google::protobuf::MethodDescriptor* method,
                             const ::google::protobuf::Message& request,
                             ::rpcz::server_channel* channel) {
  GOOGLE_DCHECK_EQ(method->service(), WorkerService_descriptor_);
  switch(method->index()) {
    case 0:
      HandleProtocol(
          *::google::protobuf::down_cast<const ::node::DataPacket*>(&request),
          ::rpcz::reply< ::node::DataPacket>(channel));
      break;
    case 1:
      HandleNotification(
          *::google::protobuf::down_cast<const ::node::DataPacket*>(&request),
          ::rpcz::reply< ::node::DataPacket>(channel));
      break;
    case 2:
      ListProtocolInterests(
          *::google::protobuf::down_cast<const ::node::VoidPacket*>(&request),
          ::rpcz::reply< ::node::InterestPacket>(channel));
      break;
    case 3:
      ListNotificationInterests(
          *::google::protobuf::down_cast<const ::node::VoidPacket*>(&request),
          ::rpcz::reply< ::node::InterestPacket>(channel));
      break;
    case 4:
      KickLogged(
          *::google::protobuf::down_cast<const ::node::DataPacket*>(&request),
          ::rpcz::reply< ::node::DataPacket>(channel));
      break;
    case 5:
      SendToClient(
          *::google::protobuf::down_cast<const ::node::DataPacket*>(&request),
          ::rpcz::reply< ::node::DataPacket>(channel));
      break;
    case 6:
      BroadcastToClient(
          *::google::protobuf::down_cast<const ::node::BroadcastRequest*>(&request),
          ::rpcz::reply< ::node::VoidPacket>(channel));
      break;
    case 7:
      SendToPlayer(
          *::google::protobuf::down_cast<const ::node::ForwardRequest*>(&request),
          ::rpcz::reply< ::node::DataPacket>(channel));
      break;
    case 8:
      PostToPlayer(
          *::google::protobuf::down_cast<const ::node::ForwardRequest*>(&request),
          ::rpcz::reply< ::node::VoidPacket>(channel));
      break;
    case 9:
      CloseClient(
          *::google::protobuf::down_cast<const ::node::DataPacket*>(&request),
          ::rpcz::reply< ::node::DataPacket>(channel));
      break;
    case 10:
      CloseAllClients(
          *::google::protobuf::down_cast<const ::node::BroadcastRequest*>(&request),
          ::rpcz::reply< ::node::VoidPacket>(channel));
      break;
    case 11:
      SendToWorker(
          *::google::protobuf::down_cast<const ::node::DataPacket*>(&request),
          ::rpcz::reply< ::node::DataPacket>(channel));
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::google::protobuf::Message& WorkerService::GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::node::DataPacket::default_instance();
    case 1:
      return ::node::DataPacket::default_instance();
    case 2:
      return ::node::VoidPacket::default_instance();
    case 3:
      return ::node::VoidPacket::default_instance();
    case 4:
      return ::node::DataPacket::default_instance();
    case 5:
      return ::node::DataPacket::default_instance();
    case 6:
      return ::node::BroadcastRequest::default_instance();
    case 7:
      return ::node::ForwardRequest::default_instance();
    case 8:
      return ::node::ForwardRequest::default_instance();
    case 9:
      return ::node::DataPacket::default_instance();
    case 10:
      return ::node::BroadcastRequest::default_instance();
    case 11:
      return ::node::DataPacket::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *reinterpret_cast< ::google::protobuf::Message*>(NULL);
  }
}

const ::google::protobuf::Message& WorkerService::GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::node::DataPacket::default_instance();
    case 1:
      return ::node::DataPacket::default_instance();
    case 2:
      return ::node::InterestPacket::default_instance();
    case 3:
      return ::node::InterestPacket::default_instance();
    case 4:
      return ::node::DataPacket::default_instance();
    case 5:
      return ::node::DataPacket::default_instance();
    case 6:
      return ::node::VoidPacket::default_instance();
    case 7:
      return ::node::DataPacket::default_instance();
    case 8:
      return ::node::VoidPacket::default_instance();
    case 9:
      return ::node::DataPacket::default_instance();
    case 10:
      return ::node::VoidPacket::default_instance();
    case 11:
      return ::node::DataPacket::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *reinterpret_cast< ::google::protobuf::Message*>(NULL);
  }
}

WorkerService_Stub::WorkerService_Stub(::rpcz::rpc_channel* channel,
                                   const ::std::string& service_name,
                                   bool owns_channel)
  : channel_(channel), service_name_(service_name),
    owns_channel_(owns_channel) {}
WorkerService_Stub::WorkerService_Stub(::rpcz::rpc_channel* channel,
                                   bool owns_channel)
  : channel_(channel), service_name_(WorkerService::descriptor()->name()),
    owns_channel_(owns_channel) {}
WorkerService_Stub::~WorkerService_Stub() {
  if (owns_channel_) delete channel_;
}

void WorkerService_Stub::HandleProtocol(const ::node::DataPacket& request,
                              ::node::DataPacket* response,
                              ::rpcz::rpc_controller* rpc_controller,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        WorkerService::descriptor()->method(0),
                        request, response, rpc_controller, done);
}
void WorkerService_Stub::HandleProtocol(const ::node::DataPacket& request,
                              ::node::DataPacket* response,
                              long deadline_ms) {
  ::rpcz::rpc_controller rpc_controller;
  rpc_controller.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        WorkerService::descriptor()->method(0),
                        request, response, &rpc_controller, NULL);
  rpc_controller.wait();
  if (!rpc_controller.ok()) {
    throw ::rpcz::rpc_error(rpc_controller);
  }
}
void WorkerService_Stub::HandleNotification(const ::node::DataPacket& request,
                              ::node::DataPacket* response,
                              ::rpcz::rpc_controller* rpc_controller,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        WorkerService::descriptor()->method(1),
                        request, response, rpc_controller, done);
}
void WorkerService_Stub::HandleNotification(const ::node::DataPacket& request,
                              ::node::DataPacket* response,
                              long deadline_ms) {
  ::rpcz::rpc_controller rpc_controller;
  rpc_controller.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        WorkerService::descriptor()->method(1),
                        request, response, &rpc_controller, NULL);
  rpc_controller.wait();
  if (!rpc_controller.ok()) {
    throw ::rpcz::rpc_error(rpc_controller);
  }
}
void WorkerService_Stub::ListProtocolInterests(const ::node::VoidPacket& request,
                              ::node::InterestPacket* response,
                              ::rpcz::rpc_controller* rpc_controller,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        WorkerService::descriptor()->method(2),
                        request, response, rpc_controller, done);
}
void WorkerService_Stub::ListProtocolInterests(const ::node::VoidPacket& request,
                              ::node::InterestPacket* response,
                              long deadline_ms) {
  ::rpcz::rpc_controller rpc_controller;
  rpc_controller.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        WorkerService::descriptor()->method(2),
                        request, response, &rpc_controller, NULL);
  rpc_controller.wait();
  if (!rpc_controller.ok()) {
    throw ::rpcz::rpc_error(rpc_controller);
  }
}
void WorkerService_Stub::ListNotificationInterests(const ::node::VoidPacket& request,
                              ::node::InterestPacket* response,
                              ::rpcz::rpc_controller* rpc_controller,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        WorkerService::descriptor()->method(3),
                        request, response, rpc_controller, done);
}
void WorkerService_Stub::ListNotificationInterests(const ::node::VoidPacket& request,
                              ::node::InterestPacket* response,
                              long deadline_ms) {
  ::rpcz::rpc_controller rpc_controller;
  rpc_controller.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        WorkerService::descriptor()->method(3),
                        request, response, &rpc_controller, NULL);
  rpc_controller.wait();
  if (!rpc_controller.ok()) {
    throw ::rpcz::rpc_error(rpc_controller);
  }
}
void WorkerService_Stub::KickLogged(const ::node::DataPacket& request,
                              ::node::DataPacket* response,
                              ::rpcz::rpc_controller* rpc_controller,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        WorkerService::descriptor()->method(4),
                        request, response, rpc_controller, done);
}
void WorkerService_Stub::KickLogged(const ::node::DataPacket& request,
                              ::node::DataPacket* response,
                              long deadline_ms) {
  ::rpcz::rpc_controller rpc_controller;
  rpc_controller.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        WorkerService::descriptor()->method(4),
                        request, response, &rpc_controller, NULL);
  rpc_controller.wait();
  if (!rpc_controller.ok()) {
    throw ::rpcz::rpc_error(rpc_controller);
  }
}
void WorkerService_Stub::SendToClient(const ::node::DataPacket& request,
                              ::node::DataPacket* response,
                              ::rpcz::rpc_controller* rpc_controller,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        WorkerService::descriptor()->method(5),
                        request, response, rpc_controller, done);
}
void WorkerService_Stub::SendToClient(const ::node::DataPacket& request,
                              ::node::DataPacket* response,
                              long deadline_ms) {
  ::rpcz::rpc_controller rpc_controller;
  rpc_controller.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        WorkerService::descriptor()->method(5),
                        request, response, &rpc_controller, NULL);
  rpc_controller.wait();
  if (!rpc_controller.ok()) {
    throw ::rpcz::rpc_error(rpc_controller);
  }
}
void WorkerService_Stub::BroadcastToClient(const ::node::BroadcastRequest& request,
                              ::node::VoidPacket* response,
                              ::rpcz::rpc_controller* rpc_controller,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        WorkerService::descriptor()->method(6),
                        request, response, rpc_controller, done);
}
void WorkerService_Stub::BroadcastToClient(const ::node::BroadcastRequest& request,
                              ::node::VoidPacket* response,
                              long deadline_ms) {
  ::rpcz::rpc_controller rpc_controller;
  rpc_controller.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        WorkerService::descriptor()->method(6),
                        request, response, &rpc_controller, NULL);
  rpc_controller.wait();
  if (!rpc_controller.ok()) {
    throw ::rpcz::rpc_error(rpc_controller);
  }
}
void WorkerService_Stub::SendToPlayer(const ::node::ForwardRequest& request,
                              ::node::DataPacket* response,
                              ::rpcz::rpc_controller* rpc_controller,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        WorkerService::descriptor()->method(7),
                        request, response, rpc_controller, done);
}
void WorkerService_Stub::SendToPlayer(const ::node::ForwardRequest& request,
                              ::node::DataPacket* response,
                              long deadline_ms) {
  ::rpcz::rpc_controller rpc_controller;
  rpc_controller.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        WorkerService::descriptor()->method(7),
                        request, response, &rpc_controller, NULL);
  rpc_controller.wait();
  if (!rpc_controller.ok()) {
    throw ::rpcz::rpc_error(rpc_controller);
  }
}
void WorkerService_Stub::PostToPlayer(const ::node::ForwardRequest& request,
                              ::node::VoidPacket* response,
                              ::rpcz::rpc_controller* rpc_controller,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        WorkerService::descriptor()->method(8),
                        request, response, rpc_controller, done);
}
void WorkerService_Stub::PostToPlayer(const ::node::ForwardRequest& request,
                              ::node::VoidPacket* response,
                              long deadline_ms) {
  ::rpcz::rpc_controller rpc_controller;
  rpc_controller.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        WorkerService::descriptor()->method(8),
                        request, response, &rpc_controller, NULL);
  rpc_controller.wait();
  if (!rpc_controller.ok()) {
    throw ::rpcz::rpc_error(rpc_controller);
  }
}
void WorkerService_Stub::CloseClient(const ::node::DataPacket& request,
                              ::node::DataPacket* response,
                              ::rpcz::rpc_controller* rpc_controller,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        WorkerService::descriptor()->method(9),
                        request, response, rpc_controller, done);
}
void WorkerService_Stub::CloseClient(const ::node::DataPacket& request,
                              ::node::DataPacket* response,
                              long deadline_ms) {
  ::rpcz::rpc_controller rpc_controller;
  rpc_controller.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        WorkerService::descriptor()->method(9),
                        request, response, &rpc_controller, NULL);
  rpc_controller.wait();
  if (!rpc_controller.ok()) {
    throw ::rpcz::rpc_error(rpc_controller);
  }
}
void WorkerService_Stub::CloseAllClients(const ::node::BroadcastRequest& request,
                              ::node::VoidPacket* response,
                              ::rpcz::rpc_controller* rpc_controller,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        WorkerService::descriptor()->method(10),
                        request, response, rpc_controller, done);
}
void WorkerService_Stub::CloseAllClients(const ::node::BroadcastRequest& request,
                              ::node::VoidPacket* response,
                              long deadline_ms) {
  ::rpcz::rpc_controller rpc_controller;
  rpc_controller.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        WorkerService::descriptor()->method(10),
                        request, response, &rpc_controller, NULL);
  rpc_controller.wait();
  if (!rpc_controller.ok()) {
    throw ::rpcz::rpc_error(rpc_controller);
  }
}
void WorkerService_Stub::SendToWorker(const ::node::DataPacket& request,
                              ::node::DataPacket* response,
                              ::rpcz::rpc_controller* rpc_controller,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        WorkerService::descriptor()->method(11),
                        request, response, rpc_controller, done);
}
void WorkerService_Stub::SendToWorker(const ::node::DataPacket& request,
                              ::node::DataPacket* response,
                              long deadline_ms) {
  ::rpcz::rpc_controller rpc_controller;
  rpc_controller.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        WorkerService::descriptor()->method(11),
                        request, response, &rpc_controller, NULL);
  rpc_controller.wait();
  if (!rpc_controller.ok()) {
    throw ::rpcz::rpc_error(rpc_controller);
  }
}

}  // namespace node
